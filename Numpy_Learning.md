# Numpy 学习

该笔记摘录自微信公众号“每天进步一点点2015”的文章[《Python数据分析之numpy学习（一）》](http://mp.weixin.qq.com/s?__biz=MzIxNjA2ODUzNg==&mid=2651435143&idx=1&sn=fb54e5d9129492a24a14fef71bf05af8#rd)和[《Python数据分析之numpy学习（二）》](http://mp.weixin.qq.com/s?__biz=MzIxNjA2ODUzNg==&mid=2651435144&idx=1&sn=5286ef757ed3acdadd6485d196b931b0#rd)。我对代码和讲解中不够清晰的地方进行了一些改动和补充。

Python模块中的numpy，这是一个处理数组的强大模块，而该模块也是其他数据分析模块（如pandas和scipy）的核心。下面将从这5个方面来介绍numpu模块的内容：

1. 数组的创建
2.有关数组的属性和函数
3. 数组元素的获取--普通索引、切片、布尔索引和花式索引
4. 统计函数与线性代数运算
5. 随机数的生成

## 数组的创建

### 一维数组的创建

可以使用numpy中的arange()函数创建一维有序数组，它是内置函数range的扩展版。

```python
In [1]: import numpy as np
In [2]: ls1 = range(10)
In [3]: list(ls1)
Out[3]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
In [4]: type(ls1)
Out[4]: range

In [5]: ls2 = np.arange(10)
In [6]: list(ls2)
Out[6]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
In [7]: type(ls2)
Out[7]: numpy.ndarray
```

通过arange生成的序列就不是简简单单的列表类型了，而是一个一维数组。

如果一维数组不是一个规律的有序元素，而是人为的输入，就需要array()函数创建了。numpy中**使用array()函数创建数组,array的首个参数一定是一个序列，可以是元组也可以是列表**。

```python
In [8]: arr1 = np.array((1,20,13,28,22))
In [9]: arr1
Out[9]: array([ 1, 20, 13, 28, 22])
In [10]: type(arr1)
Out[10]: numpy.ndarray
```

上面是由元组序列构成的一维数组。

```python
In [11]: arr2 = np.array([1,1,2,3,5,8,13,21])
In [12]: arr2
Out[12]: array([ 1,  1,  2,  3,  5,  8, 13, 21])
In [13]: type(arr2)
Out[13]: numpy.ndarray
```

上面是由列表序列构成的一维数组。

### 二维数组的创建

二维数组的创建，其实在就是**列表套列表或元组套元组**
```python
In [14]: arr3 = np.array(((1,1,2,3),(5,8,13,21),(34,55,89,144)))
In [15]: arr3
Out[15]:
array([[  1,   1,   2,   3],
[  5,   8,  13,  21],
[ 34,  55,  89, 144]])
```

上面是使用元组套元组的方式。

```python
In [16]: arr4 = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])
In [17]: arr4
Out[17]:
array([[ 1,  2,  3,  4],
[ 5,  6,  7,  8],
[ 9, 10, 11, 12]])
```

上面是使用列表套列表的方式。

对于高维数组在将来的数据分析中用的比较少，这里关于高维数组的创建就不赘述了，构建方法仍然是使用嵌套的方式。

上面所介绍的都是人为设定的一维、二维或高维数组，numpy中也提供了几种特殊的数组，它们是：

```python
In [18]: np.ones(3)  #返回一维元素全为1的数组
Out[18]: array([ 1.,  1.,  1.])

In [19]: np.ones([3,4])  #返回元素全为1的3×4二维数组
Out[19]:
array([[ 1.,  1.,  1.,  1.],
[ 1.,  1.,  1.,  1.],
[ 1.,  1.,  1.,  1.]])

In [20]: np.zeros(3) #返回一维元素全为0的数组
Out[20]: array([ 0.,  0.,  0.])

In [21]: np.zeros([3,4]) #返回元素全为0的3×4二维数组
Out[21]:
array([[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.],
[ 0.,  0.,  0.,  0.]])

In [22]: np.empty(3) #返回一维空数组
Out[22]: array([  1.13224202e+277,   6.00769955e-307,   2.55195390e-303])

In [23]: np.empty([3,4]) #返回3×4二维空数组
Out[23]:
array([[  1.09494983e-311,   8.19904309e-314,   1.09678092e-311,   1.09494983e-311],
       [  2.09290548e-313,   1.09678288e-311,   1.09494983e-311,   3.36629926e-313],
       [  1.09678538e-311,   4.03179200e-313,   1.09678287e-311,   1.09494983e-311]])
```

原文中对于`np.empty`的举例不够严谨，这个函数返回的是指定规模未经初始化的数组，速度要比 `ones` 和 `zeros` 快，但里面的值都是随机的，要谨慎使用。

## 有关数组的属性和函数

当一个数组构建好后，我们看看关于数组本身的操作又有哪些属性和函数：

```python
In [24]: arr3
Out[24]:
array([[  1,   1,   2,   3],
[  5,   8,  13,  21],
[ 34,  55,  89, 144]])

In [25]: arr3.shape  #shape方法返回数组的行数和列数
Out[25]: (3, 4)

In [26]: arr3.dtype  #dtype方法返回数组的数据类型
Out[26]: dtype('int32')

In [27]: a = arr3.ravel()    #通过ravel的方法将数组拉直（多维数组降为一维数组）
In [28]: a
Out[28]: array([  1,   1,   2,   3,   5,   8,  13,  21,  34,  55,  89, 144])

In [29]: b = arr3.flatten()  #通过flatten的方法将数组拉直
In [30]: b
Out[30]: array([  1,   1,   2,   3,   5,   8,  13,  21,  34,  55,  89, 144])
```

两者的区别在于**ravel方法生成的是原数组的视图，无需占有内存空间，但视图的改变会影响到原数组的变化。而flatten方法返回的是真实值，其值的改变并不会影响原数组的更改**。

通过下面的例子也许就能明白了：

```python
In [31]: b[:3] = 0
In [32]: arr3
Out[32]:
array([[  1,   1,   2,   3],
[  5,   8,  13,  21],
[ 34,  55,  89, 144]])
```

通过更改b的值，原数组没有变化。

```python
In [33]: a[:3] = 0
In [34]: arr3
Out[34]:
array([[  0,   0,   0,   3],
[  5,   8,  13,  21],
[ 34,  55,  89, 144]])
```

a的值变化后，会导致原数组跟着变化。

```python
In [35]: arr4
Out[35]:
array([[ 1,  2,  3,  4],
[ 5,  6,  7,  8],
[ 9, 10, 11, 12]])

In [36]: arr4.ndim   #返回数组的维数(嵌套的层数)
Out[36]: 2

In [37]: arr4.size   #返回数组元素的个数
Out[37]: 12

In [38]: arr4.T  #返回数组的转置结果
Out[38]:
array([[ 1,  5,  9],
[ 2,  6, 10],
[ 3,  7, 11],
[ 4,  8, 12]])
```

**如果数组的数据类型为复数**的话，real方法可以返回复数的实部，imag方法返回复数的虚部。

介绍完数组的一些**方法**后，接下来我们看看数组自身有哪些**函数**可操作：

```python
In [39]: len(arr4) #返回数组有多少行
Out[39]: 3

In [40]: arr3
Out[40]:
array([[  0,   0,   0,   3],
[  5,   8,  13,  21],
[ 34,  55,  89, 144]])

In [41]: arr4
Out[41]:
array([[ 1,  2,  3,  4],
[ 5,  6,  7,  8],
[ 9, 10, 11, 12]])

In [42]: np.hstack((arr3,arr4))
Out[42]:
array([[  0,   0,   0,   3,   1,   2,   3,   4],
[  5,   8,  13,  21,   5,   6,   7,   8],
[ 34,  55,  89, 144,   9,  10,  11,  12]])
```

**横向拼接**arr3和arr4两个数组，但必须满足两个数组的**行数相同**。

```python
In [43]: np.vstack((arr3,arr4))
Out[43]:
array([[  0,   0,   0,   3],
[  5,   8,  13,  21],
[ 34,  55,  89, 144],
[  1,   2,   3,   4],
[  5,   6,   7,   8],
[  9,  10,  11,  12]])
```

**纵向拼接**arr3和arr4两个数组，但必须满足两个数组的**列数相同**。

```python
In [44]: np.column_stack((arr3,arr4))    #与hstack函数具有一样的效果
Out[44]:
array([[  0,   0,   0,   3,   1,   2,   3,   4],
[  5,   8,  13,  21,   5,   6,   7,   8],
[ 34,  55,  89, 144,   9,  10,  11,  12]])

In [45]: np.row_stack((arr3,arr4))    #与vstack函数具有一样的效果
Out[45]:
array([[  0,   0,   0,   3],
[  5,   8,  13,  21],
[ 34,  55,  89, 144],
[  1,   2,   3,   4],
[  5,   6,   7,   8],
[  9,  10,  11,  12]])
```

reshape()函数和resize()函数可以重新设置数组的行数和列数：

```python
In [46]: arr5 = np.arange(24)
In [47]: arr5    #此为一维数组
Out[47]:
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23])

In [48]: a = arr5.reshape(4,6)
In [49]: a
Out[49]:
array([[ 0,  1,  2,  3,  4,  5],
[ 6,  7,  8,  9, 10, 11],
[12, 13, 14, 15, 16, 17],
[18, 19, 20, 21, 22, 23]])
```

通过reshape函数将一维数组设置为二维数组，且为4行6列的数组。**reshape函数不会改变原数组**。

```python
In [50]: a.resize(6,4)
In [51]: a
Out[51]:
array([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11],
[12, 13, 14, 15],
[16, 17, 18, 19],
[20, 21, 22, 23]])
```

通过**resize函数会直接改变原数组的形状**。

数组转换：tolist将数组转换为列表，astype()强制转换数组的数据类型，下面是两个函数的例子：

```python
In [53]: b = a.tolist()
In [54]: b
Out[54]:
[[0, 1, 2, 3],
[4, 5, 6, 7],
[8, 9, 10, 11],
[12, 13, 14, 15],
[16, 17, 18, 19],
[20, 21, 22, 23]]
In [55]: type(b)
Out[55]: list

In [56]: c = a.astype(float)
In [57]: c
Out[57]:
array([[  0.,   1.,   2.,   3.],
[  4.,   5.,   6.,   7.],
[  8.,   9.,  10.,  11.],
[ 12.,  13.,  14.,  15.],
[ 16.,  17.,  18.,  19.],
[ 20.,  21.,  22.,  23.]])

In [58]: a.dtype
Out[58]: dtype('int32')
In [59]: c.dtype
Out[59]: dtype('float64')
```

## 数组元素的获取

通过索引和切片的方式获取数组元素，一维数组元素的获取与列表、元组的获取方式一样：

```python
In [60]: arr7 = np.arange(10)
In [61]: arr7
Out[61]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
In [62]: arr7[3]     #获取第4个元素
Out[62]: 3

In [63]: arr7[:3]    #获取前3个元素
Out[63]: array([0, 1, 2])

In [64]: arr7[3:]    #获取第4个元素即之后的所有元素
Out[64]: array([3, 4, 5, 6, 7, 8, 9])

In [65]: arr7[-2:]   #获取末尾的2个元素
Out[65]: array([8, 9])

In [66]: arr7[::2]   #从第1个元素开始，获取步长为2的所有元素
Out[66]: array([0, 2, 4, 6, 8])
```

补充一下，如果要获取多个元素，且它们的索引没有固定步长这样的规则的话，可以**传入一个list作为索引**：

```python
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> a[[0,3,4]]      #返回数组的第1，4，5个元素
array([0, 3, 4])
```

二维数组元素的获取：

```python
In [67]: arr8 = np.arange(12).reshape(3,4)
In [68]: arr8
Out[68]:
array([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11]])

In [69]: arr8[1]     #返回数组的第2行
Out[69]: array([4, 5, 6, 7])

In [70]: arr8[:2]    #返回数组的前2行
Out[70]:
array([[0, 1, 2, 3],
[4, 5, 6, 7]])

In [71]: arr8[[0,2]]     #返回指定的第1行和第3行
Out[71]:
array([[ 0,  1,  2,  3],
[ 8,  9, 10, 11]])

In [72]: arr8[:,0]  #返回数组的第1列
Out[72]: array([0, 4, 8])

In [73]: arr8[:,-2:]    #返回数组的后2列
Out[73]:
array([[ 2,  3],
[ 6,  7],
[10, 11]])

In [74]: arr8[:,[0,2]]   #返回数组的第1列和第3列
Out[74]:
array([[ 0,  2],
[ 4,  6],
[ 8, 10]])

In [75]: arr8[1,2]   #返回数组中第2行第3列对应的元素
Out[75]: 6
```

**布尔索引，即索引值为True和False，需要注意的是布尔索引必须是数组对象。**

```python
In [76]: log = np.array([True,False,False,True,True,False])
In [77]: arr9 = np.arange(24).reshape(6,4)
In [78]: arr9
Out[78]:
array([[ 0,  1,  2,  3],
[ 4,  5,  6,  7],
[ 8,  9, 10, 11],
[12, 13, 14, 15],
[16, 17, 18, 19],
[20, 21, 22, 23]])

In [79]: arr9[log]   #返回所有为True的对应行
Out[79]:
array([[ 0,  1,  2,  3],
[12, 13, 14, 15],
[16, 17, 18, 19]])

In [80]: arr9[-log]  #通过负号筛选出所有为False的对应行
Out[80]:
array([[ 4,  5,  6,  7],
[ 8,  9, 10, 11],
[20, 21, 22, 23]])
```

举一个场景，一维数组表示区域，二维数组表示观测值，如何选取目标区域的观测？

```python
In [81]: area = np.array(['A','B','A','C','A','B','D'])
In [82]: area
Out[82]:
array(['A', 'B', 'A', 'C', 'A', 'B', 'D'],
dtype='<U1')

In [83]: observes = np.arange(21).reshape(7,3)
In [84]: observes
Out[84]:
array([[ 0,  1,  2],
[ 3,  4,  5],
[ 6,  7,  8],
[ 9, 10, 11],
[12, 13, 14],
[15, 16, 17],
[18, 19, 20]])

In [85]: observes[area == 'A']     #这里[]内的"area == 'A'"语句返回的就是一个全是布尔值的数组对象
Out[85]:
array([[ 0,  1,  2],
[ 6,  7,  8],
[12, 13, 14]])
```

返回所有A区域的观测。

```python
In [86]: observes[(area == 'A') | (area == 'D')] #条件值需要在&(and),|(or)两端用圆括号括起来
Out[86]:
array([[ 0,  1,  2],
[ 6,  7,  8],
[12, 13, 14],
[18, 19, 20]])
```

返回所有A区域和D区域的观测。

当然，布尔索引也可以与普通索引或切片混合使用：

```python
In [87]: observes[area == 'A'][:,[0,2]]
Out[87]:
array([[ 0,  2],
[ 6,  8],
[12, 14]])
```

返回A区域的所有行，且只获取第1列与第3列数据。

**花式索引：实际上就是将数组作为索引将原数组的元素提取出来**

```python
In [88]: arr10 = np.arange(1,29).reshape(7,4)
In [89]: arr10
Out[89]:
array([[ 1,  2,  3,  4],
[ 5,  6,  7,  8],
[ 9, 10, 11, 12],
[13, 14, 15, 16],
[17, 18, 19, 20],
[21, 22, 23, 24],
[25, 26, 27, 28]])

In [90]: arr10[[4,1,3,5]]  #按照指定顺序返回指定行
Out[90]:
array([[17, 18, 19, 20],
[ 5,  6,  7,  8],
[13, 14, 15, 16],
[21, 22, 23, 24]])

In [91]: arr10[[4,1,5]][:,[0,2,3]] #返回指定的行与列，可以分解为两条命令来看
Out[91]:
array([[17, 19, 20],
[ 5,  7,  8],
[21, 23, 24]])

In [92]: arr10[[4,1,5],[0,2,3]] # 返回指定位置的数字
Out[92]: array([17,  7, 24])
```

请注意！这与上面的返回结果是截然不同的，上面的命令返回的是二维数组，而这条命令返回的是一维数组。P.S.原文这里没有解释的很清楚，简单来说，如果**在方括号内使用两个甚至多个数组/列表作为索引，中间以逗号分割**，那么数组的顺序对应的就是从低维到高维，比如 `In [92]` 中第一个列表的第一个元素是4，第二个列表的第一个元素是0，这就表示要从arr10这个二维数组中取出的第一个元素在第一维第5个对象和第二维第1个对象交叠的地方，也即二维数组的第5行第1个元素17。最后会将所有取出的元素放入一个一维数组中返回。但如果某一维没有用数组/列表指定，而是使用了冒号表示取所有的话，返回的就是二维对象了。再举一个例子吧：

```python
>>> a = np.arange(10).reshape(2,5)
>>> a
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])

>>> a[:,[0,4]]
array([[0, 4],
       [5, 9]])

>>> a[[0,0,1,1],[0,4,0,4]]
array([0, 4, 5, 9])
```

如果想使用比较简单的方式**返回指定行与列的二维数组**的话，可以使用ix_()函数

```python
In [93]: arr10[np.ix_([4,1,5],[0,2,3])] #    允许我们用指定位置的方式，并且保持返回的数组形状不变
Out[93]:
array([[17, 19, 20],
[ 5,  7,  8],
[21, 23, 24]])
```

这与 `arr10[[4,1,5]][:,[0,2,3]]` 返回的结果是一致的。

## 统计函数与线性代数运算

### 统计函数

统计运算中常见的聚合函数有：最小值、最大值、中位数、均值、方差、标准差等。首先来看看数组元素级别的计算：

```python
In [94]: arr11 = 5-np.arange(1,13).reshape(4,3)
# randint返回指定区间的随机整数，区间左闭右开，size不指定时为None，返回1个随机整数
In [95]: arr12 = np.random.randint(1,10,size = 12).reshape(4,3)
In [96]: arr11
Out[96]:
array([[ 4,  3,  2],
[ 1,  0, -1],
[-2, -3, -4],
[-5, -6, -7]])

In [97]: arr12
Out[97]:
array([[1, 3, 7],
[7, 3, 7],
[3, 7, 4],
[6, 1, 2]])

In [98]: arr11 ** 2    #计算每个元素的平方
Out[98]:
array([[16,  9,  4],
[ 1,  0,  1],
[ 4,  9, 16],
[25, 36, 49]])

In [99]: np.sqrt(arr11)  #计算每个元素的平方根
Out[99]:
array([[ 2.        ,  1.73205081,  1.41421356],
[ 1.        ,  0.        ,         nan],
[        nan,         nan,         nan],
[        nan,         nan,         nan]])
```

由于负值的平方根没有意义，故返回nan。

```python
In [100]: np.exp(arr11)   #计算每个元素的指数值，exp(a) 即 e^a
Out[100]:
array([[  5.45981500e+01,   2.00855369e+01,   7.38905610e+00],
[  2.71828183e+00,   1.00000000e+00,   3.67879441e-01],
[  1.35335283e-01,   4.97870684e-02,   1.83156389e-02],
[  6.73794700e-03,   2.47875218e-03,   9.11881966e-04]])

In [101]: np.log(arr12)   #计算每个元素的自然对数值，log(a) 即 log_e(a)，还有log2和log10两个函数
Out[101]:
array([[ 0.        ,  1.09861229,  1.94591015],
[ 1.94591015,  1.09861229,  1.94591015],
[ 1.09861229,  1.94591015,  1.38629436],
[ 1.79175947,  0.        ,  0.69314718]])

In [102]: np.abs(arr11)   #计算每个元素的绝对值
Out[102]:
array([[4, 3, 2],
[1, 0, 1],
[2, 3, 4],
[5, 6, 7]])
```

相同形状数组间元素的操作：

```python
In [103]: arr11 + arr12   #加
Out[103]:
array([[ 5,  6,  9],
[ 8,  3,  6],
[ 1,  4,  0],
[ 1, -5, -5]])

In [104]: arr11 - arr12   #减
Out[104]:
array([[  3,   0,  -5],
[ -6,  -3,  -8],
[ -5, -10,  -8],
[-11,  -7,  -9]])

In [105]: arr11 * arr12   #乘
Out[105]:
array([[  4,   9,  14],
[  7,   0,  -7],
[ -6, -21, -16],
[-30,  -6, -14]])

In [106]: arr11 / arr12   #除
Out[106]:
array([[ 4.        ,  1.        ,  0.28571429],
[ 0.14285714,  0.        , -0.14285714],
[-0.66666667, -0.42857143, -1.        ],
[-0.83333333, -6.        , -3.5       ]])

In [107]: arr11 // arr12  #整除
Out[107]:
array([[ 4,  1,  0],
[ 0,  0, -1],
[-1, -1, -1],
[-1, -6, -4]], dtype=int32)

In [108]: arr11 % arr12   #取余
Out[108]:
array([[0, 0, 2],
[1, 0, 6],
[1, 4, 0],
[1, 0, 1]], dtype=int32)
```


