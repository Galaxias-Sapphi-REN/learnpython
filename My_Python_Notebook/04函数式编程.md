# 函数式编程

**函数**是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。

**函数式编程**（请注意多了一个**“式”**字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其**思想更接近数学计算**。

我们首先要搞明白**计算机（Computer）**和**计算（Compute）**的概念。

- 在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以汇编语言是最贴近计算机的语言。

- 计算则是指数学意义上的计算，越是抽象的计算，离计算机硬件越远。

对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。

归纳一下：

|  | 低级语言 | 高级语言 |
|:-:|:-:|:-:|
| 特点 | 贴近计算机 | 贴近计算（数学意义上） |
| 抽象程度 | 低 | 高 |
| 执行效率 | 高 | 低 |
| 例子 | 汇编和C | Lisp |

函数式编程就是一种**抽象程度很高的编程范式**，纯粹的函数式编程语言编写的函数**没有变量**，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为**没有副作用**。而允许使用变量的程序设计语言，由于函数内部的**变量状态不确定**，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。

函数式编程的一个特点就是，**允许把函数本身作为参数传入另一个函数，还允许返回一个函数**！

Python**仅对函数式编程提供部分支持**。由于Python允许使用变量，因此，**Python不是纯函数式编程语言**。

## 函数式编程的三大特性

1. **immutable data**<br>
变量不可变，或者说没有变量，只有常量。 函数式编程输入确定时输出就是确定的，函数内部的变量和函数外部的没有关系，不会受到外部操作的影响。

2. **first class functions**<br>
第一类函数(也称高阶函数)，意思是函数可以向变量一样用，可以像变量一样创建、修改、传递和返回。 这就允许我们把大段代码拆成函数一层层地调用，这种面向过程的写法相比循环更加直观。

3. **尾递归优化**<br>
之前一章的递归函数中已经提及过了，就是递归时返回函数本身而非表达式。 可惜Python中没有这个特性。

---

<br>

## 函数式编程的几个技术

1. **map & reduce**<br>
函数式编程最常见的技术就是对一个集合做Map和Reduce操作。这比起传统的面向过程的写法来说，在代码上要更容易阅读（不需要使用一堆for、while循环来倒腾数据，而是使用更抽象的Map函数和Reduce函数）。

2. **pipeline**<br>
这个技术的意思是把函数实例成一个一个的action，然后把一组action放到一个数组或是列表中组成一个action list，然后把数据传给这个action list，数据就像通过一个pipeline一样顺序地被各个函数所操作，最终得到我们想要的结果。

3. **recursing**<br>
递归最大的好处就简化代码，它可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。

4. **currying**<br>
把一个函数的多个参数分解成多个函数， 然后把函数多层封装起来，每层函数都返回一个函数去接收下一个参数这样，可以简化函数的多个参数（减少函数的参数数目）。

5. **higher order function**<br>
高阶函数：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出。

对currying进行一点补充，举个例子：

```python
def pow(i, j):
    return i**j

def square(i):
    return pow(i, 2)
```

这里就是把原本平方函数`square`的参数j分解了，它返回幂函数`pow`函数，把幂次封装在里面，从而减少了求平方时所需用到的参数。

关于函数式编程的一些概念理解可以看[傻瓜函数式编程](http://www.kancloud.cn/kancloud/functional-programm-for-rest/56931)或者英文原版的[Functional Programming For The Rest of Us](http://www.defmacro.org/ramblings/fp.html)。

---

<br>

## 函数式编程的几个好处

1. **parallelization 并行**<br>
在并行环境下，各个线程之间不需要同步或互斥(变量都是内部的，不需要共享)。

2. **lazy evaluation 惰性求值**<br>
表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。

3. **determinism 确定性**<br>
输入是确定的，输出就是确定的。

### 简单举例

以往面向过程式的编程需要引入额外的逻辑变量以及使用循环：

```python
upname =['HAO', 'CHEN', 'COOLSHELL']
lowname =[]
for i in range(len(upname)):
    lowname.append( upname[i].lower() )
```

而函数式编程则非常简洁易懂：

```python
def toUpper(item):
  return item.upper()

upper_name = map(toUpper, ["hao", "chen", "coolshell"])
print upper_name
```

再看一个计算一个列表中所有正数的平均数的例子：

```python
num =[2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]
positive_num_cnt = 0
positive_num_sum = 0
for i in range(len(num)):
    if num[i] > 0:
        positive_num_cnt += 1
        positive_num_sum += num[i]

if positive_num_cnt > 0:
    average = positive_num_sum / positive_num_cnt

print average
```

如果采用函数式编程：

```python
positive_num = filter(lambda x: x>0, num)
average = reduce(lambda x,y: x+y, positive_num) / len( positive_num )
```

可以看到**函数式编程减少了变量的使用，也就减少了出Bug的可能，维护更加方便。可读性更高，代码更简洁**。

更多的例子和解析详见[函数式编程](http://coolshell.cn/articles/10822.html)。

---

<br>

## 高阶函数

前面已经提到了函数式编程中的高阶函数特性，这一节将针对Python中的使用方式进行更详细的描述。

### 变量可以指向函数

```python
>>> abs
<built-in function abs>
>>> f = abs
>>> f
<built-in function abs>
>>> f(-10)
10
```

这个例子表明在Python中变量是可以指向函数的，并且这样赋值的变量能够作为函数的别名使用。

---

### 函数名也是变量

```python
>>> abs = 10
>>> abs(-10)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'int' object is not callable
```

这里把abs函数赋值为10，这样赋值以后abs就变成一个整形变量，指向int型对象10而不指向原本的函数了。所以无法再作为函数使用。

想恢复abs函数要重启Python交互环境。 abs函数定义在 `__builtin__` 模块中，要让修改abs变量的指向在其它模块也生效，用 `__builtin__.abs = 10` 就可以了。 当然**实际写代码绝对不应该这样做**..

---

### 传入函数

函数能够作为参数传递，接收这样的参数的函数就称为高阶函数。 简单举例：

```python
def add(x, y, f):
    return f(x) + f(y)

>>> add(-5, 6, abs)
11
```

这里abs函数可以作为一个参数传入我们编写的add函数中，add函数就是一个高阶函数。

---

### map/reduce

map()函数和reduce()函数是Python的两个内建函数(BIF)。

#### map函数

map()函数接收两个参数，一个是函数，一个是**Iterable对象**，map将传入的函数依次作用到序列的每个元素，并把结果作为**Iterator对象**（惰性序列，可以用list转换为列表输出）返回。例如：

```python
>>> def f(x):
...     return x * x
...
>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
```

这里直接使用list()函数将迭代器对象转换为一个列表。

写循环也能达到同样效果，但是显然没有map()函数直观。 map()函数作为高阶函数，大大简化了代码，更易理解。

```python
>>> list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
['1', '2', '3', '4', '5', '6', '7', '8', '9']
```

将一个整数列表转换为字符列表仅仅需要一行代码。

#### reduce函数

reduce接收两个参数，一个是函数（假设该函数称为f），一个是Iterable对象（假设是l）。函数f必须接收两个参数，reduce函数每次会把上一次函数f返回的值和l的下一个元素传入到f中，直到l中所有元素都参与过运算时返回函数f最后返回的值（第一次传入时传入l的头两个元素）。

```python
>>> from functools import reduce
>>> def add(x, y):
...     return x + y
...
>>> reduce(add, [1, 3, 5, 7, 9])
25
```

这里举了一个最简单的序列求和作例子(当然实际上我们直接用sum()函数更方便，这里只是为了举例子)。 这里reduce函数每次将add**作用于序列的前两个元素**，并**把结果返回序列的头部**，直到序列只剩下1个元素就返回结果（这样理解可能更直观一些）。

```python
>>> from functools import reduce
>>> def fn(x, y):
...     return x * 10 + y
...
>>> def char2num(s):
...     return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s] #字符对应整数的dict，返回传入字符对应的整数
...
>>> reduce(fn, map(char2num, '13579'))
13579
```

可以整理一下，作为一个整体的str2int函数：

```python
def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]
    return reduce(fn, map(char2num, s))
```

使用lambda匿名函数还可以进一步简化：

```python
def char2num(s):
    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
```

#### 练习

> 1.利用map()函数，把不规范的英文名字变为首字母大写其他字母小写的规范名字。

**Hint**:

- 字符串支持切片操作，并且可以用加号做字符串拼接。
- 转换大写用upper函数，转换小写用lower函数。

```python
def normalize(name):
    return name[0].upper()+name[1:].lower()

L1 = ['adam', 'LISA', 'barT']
L2 = list(map(normalize, L1))
print(L2)
```

> 2.编写一个prod()函数，可以接受一个list并利用reduce()求积。

**Hint**:

- 用匿名函数做两数相乘
- 用reduce函数做归约，得到列表元素连乘之积。

```python
from functools import reduce
def prod(L):
    return reduce(lambda x,y: x*y,L)

print('3 * 5 * 7 * 9 =', prod([3, 5, 7, 9]))
```

> 3.利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.45。

**Hint**:

- 这题的思路是找到小数点的位置i(从个位开始数i个数字之后)，然后让转换出的整数除以10的i次方。
- 另外一种思路是在转换时遇到小数点后，改变转换的方式由 `num*10+当前数字` 变为 `num+当前数字/point`。 point初始为1，每次加入新数字前除以10。

```python
from functools import reduce
from math import pow

def chr2num(s):
    return {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[s]

def str2float(s):
    return reduce(lambda x,y:x*10+y,map(chr2num,s.replace('.',''))) / pow(10,len(s)-s.find('.')-1)

print(str2float('985.64785'))
```

---

### filter

filter()函数同样是内建函数，用于过滤序列。 filter()接收一个函数和一个Iterable对象。 和map()不同的时，filter()把传入的函数依次作用于每个元素，然后**根据函数返回值是True还是False决定保留还是丢弃该元素**。

简单的奇数筛选例子：

```python
def is_odd(n):
    return n % 2 == 1

list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]
```

筛掉列表的空字符串：

```python
def not_empty(s):
    return s and s.strip()

list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
# 结果: ['A', 'B', 'C']
```

其中，`strip` 函数用于删除字符串中特定字符，格式为：`s.strip(rm)`，删除s字符串中开头、结尾处的包含在rm删除序列中的字符。 rm为空时默认删除空白符(包括'\n', '\r',  '\t',  ' ')。

注意到 `filter()` 函数返回的是一个 **Iterator对象**，也就是一个**惰性序列**，所以要强迫 `filter()` 完成计算结果，需要用 `list()` 函数获得所有结果并返回list。

filter函数最重要的一点就是正确地定义一个**筛选函数**（即传入filter作为参数的那个函数)。

#### 练习

> 1.用filter筛选素数

这里使用**埃氏筛法**。

> 首先，列出从2开始的所有自然数，构造一个序列：

    2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, ...

> 取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉：

    3, 5, 7, 9, 11, 13, 15, 17, 19, ...

> 取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉：

    5, 7, 11, 13, 17, 19, ...

> 以此类推...

首先构造一个生成器，输出3开始的奇数序列:

```python
def _odd_iter():
    n = 1
    while True:
        n = n + 2
        yield n
```

然后定义一个筛选函数，传入n，判断x能否除尽n：

```python
def _not_divisible(n):
    return lambda x: x % n > 0
```

这里x是匿名函数的参数，**由外部提供**。

然后就是定义返回素数的生成器了。

- 首先输出素数2，然后初始化奇数队列，每次输出队首(必然是素数，因为前一轮的过滤已经排除了比当前队首小且非素数的数)。

- 构造新的队列，每次用当前序列最小的数作为除数，检验后面的数是否素数。

定义如下：

```python
def primes():
    yield 2
    it = _odd_iter() # 初始序列
    while True:
        n = next(it) # 返回序列的第一个数
        yield n
        it = filter(_not_divisible(n), it) # 构造新序列
```

这里因为it是一个迭代器，每次使用next就得到队列的下一个元素，实际上就类似队列的出列操作，挤掉队首，不用担心重复。

然后这里filter的原理，就是把当前it队列的每个数都放进_not_divisible(n)中检测一下，注意**不是作为参数n传入而是作为匿名函数的参数x传入**！

`_not_divisible(n)` 实际是**作为一个整体来看**的，它返回一个**自带参数n的函数**(也即那个匿名函数)，然后filter再把列表每一个元素一一传返回的匿名函数中。一定要搞清楚这一点。

- 最后，因为primes产生的也是一个无限长的惰性序列，我们一般不需要求那么多，简单写个循环用作退出即可：

```python
# 打印1000以内的素数:
for n in primes():
    if n < 1000:
        print(n)
    else:
        break
```

<br>

> 2.用filter筛选回文数

**Hint**:

- str可以把整数转换为字符串
- [::-1]可以得到逆序的列表。

```python
def is_palindrome(n):
    return str(n) == str(n)[::-1]

print(list(filter(is_palindrome, range(0,1001))))
```

---
