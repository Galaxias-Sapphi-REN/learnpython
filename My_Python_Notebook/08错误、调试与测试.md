# 错误、调试与测试

## 简述

在程序运行过程中我们总会遇到各种各样的**错误**。有的错误是程序编写有问题造成的，比如本来应该输出整数结果输出了字符串，这种错误我们通常称之为**bug**，bug是必须修复的；有的错误是用户输入造成的，比如让用户输入email地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理；还有一类错误是完全无法预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为**异常**，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。Python内置了一套异常处理机制，可以帮助我们处理这些错误。

此外，在编写代码时，我们可能会需要跟踪程序的执行，查看变量的值是否正确，然后再进行调整或者下一步操作，这个过程称为**调试**。Python的**pdb**可以让我们以**单步方式**执行代码，从而方便地调试程序。

最后，编写**测试**也很重要。编写好测试文件，这样当我们改动了代码或者实现了新的功能时，只需再运行一遍测试，就能知道原来的功能有没有出错，程序是否依然能输出我们期望的结果了。

---

<br>

## 错误处理

### 错误码

在程序运行的过程中，如果发生了错误，可以**返回一个事先约定的错误代码**，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数 `open()`，成功时返回文件描述符（就是一个整数），出错时返回-1。

用错误码来表示是否出错十分不便，因为**函数本身既可能返回正常结果又可能返回错误码**，所以调用者不得不用大量的代码来判断属于哪一种情况。例如：

```python
def foo():
    r = some_function()
    if r==(-1):
        return (-1)
    # do something
    return r

def bar():
    r = foo()
    if r==(-1):
        print('Error')
    else:
        pass
```

函数 `foo` 既可能返回正常结果又可能返回错误码，因此调用 `foo` 的函数 `bar` 就不得不先进行判断，检查返回的是正常结果还是错误码。这种情况在有多种错误码时显得更为麻烦。

还有一个很大的缺点是，使用错误码时，一旦出错，就必须把这个错误码一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息）。假如上面例子中 `bar` 函数无法处理错误，就必须继续返回错误码给调用 `bar` 的上级函数，以此类推。并且在返回的过程中，我们在每个中间函数中都要对错误码进行判断，这样写出来的程序有“半壁江山”都被处理错误的逻辑占据了，着实可怕。。。

有没有可以替代错误码又能处理错误的方案呢？有的！基本上，所有高级语言都内置了一套 `try...except...finally...` 的错误处理机制，Python也不例外，在下一小节中将介绍这种错误处理机制。
