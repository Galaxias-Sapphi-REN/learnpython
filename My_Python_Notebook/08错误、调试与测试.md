# 错误、调试与测试

## 简述

在程序运行过程中我们总会遇到各种各样的**错误**。有的错误是程序编写有问题造成的，比如本来应该输出整数结果输出了字符串，这种错误我们通常称之为**bug**，bug是必须修复的；有的错误是用户输入造成的，比如让用户输入email地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理；还有一类错误是完全无法预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为**异常**，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。Python内置了一套异常处理机制，可以帮助我们处理这些错误。

此外，在编写代码时，我们可能会需要跟踪程序的执行，查看变量的值是否正确，然后再进行调整或者下一步操作，这个过程称为**调试**。Python的**pdb**可以让我们以**单步方式**执行代码，从而方便地调试程序。

最后，编写**测试**也很重要。编写好测试文件，这样当我们改动了代码或者实现了新的功能时，只需再运行一遍测试，就能知道原来的功能有没有出错，程序是否依然能输出我们期望的结果了。

---

<br>

## 错误处理

### 错误码

在程序运行的过程中，如果发生了错误，可以**返回一个事先约定的错误代码**，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数 `open()`，成功时返回文件描述符（就是一个整数），出错时返回-1。

用错误码来表示是否出错十分不便，因为**函数本身既可能返回正常结果又可能返回错误码**，所以调用者不得不用大量的代码来判断属于哪一种情况。例如：

```python
def foo():
    r = some_function()
    if r==(-1):
        return (-1)
    # do something
    return r

def bar():
    r = foo()
    if r==(-1):
        print('Error')
    else:
        pass
```

函数 `foo` 既可能返回正常结果又可能返回错误码，因此调用 `foo` 的函数 `bar` 就不得不先进行判断，检查返回的是正常结果还是错误码。这种情况在有多种错误码时显得更为麻烦。

还有一个很大的缺点是，使用错误码时，一旦出错，就必须把这个错误码一级一级上报，直到某个函数可以处理该错误（比如，给用户输出一个错误信息）。假如上面例子中 `bar` 函数无法处理错误，就必须继续返回错误码给调用 `bar` 的上级函数，以此类推。并且在返回的过程中，我们在每个中间函数中都要对错误码进行判断，这样写出来的程序有“半壁江山”都被处理错误的逻辑占据了，着实可怕。。。

有没有可以替代错误码又能处理错误的方案呢？有的！基本上，所有高级语言都内置了一套 `try...except...finally...` 的错误处理机制，Python也不例外，在下一小节中将介绍这种错误处理机制。

---

### try...except...finally

`try...except...finally...` 机制的工作方式是这样的：

- 当我们认为某段代码可能会出错时，可以用 `try` 来运行这段代码，如果运行出错，则这段代码会**终止在错误出现的地方**；
- 如果后续代码中 `except` 语句成功捕获到错误，程序就会执行 `except` 语句块内的代码处理错误。如果没有捕获到，则错误没有得到处理，程序就会停止运行；
- 最后，**无论是否出错，无论是否成功捕获到错误**，`finally` 语句块内的代码都会被执行。

`try...except...finally...` 机制中，我们**可以不使用 `finally` 语句块，但 `try` 和 `except` 是一定要同时出现的**，`except` 不一定能成功捕获 `try` 语句块内的错误，如果捕获不成功，程序就会终止运行。

接下来看一个使用 `try...except...finally...` 机制处理错误的具体案例：

```python
try:
    print('try...')
    r = 10 / 0
    print('result:', r)
except ZeroDivisionError as e:
    print('except:', e)
finally:
    print('finally...')
print('END')
```

上面的代码在计算 `10 / 0` 时会产生一个除零错误，得到输出：

```python
try...
except: division by zero
finally...
END
```

从输出可以看到，当错误发生时，后续语句 `print('result:', r)` 不会被执行，由于 `except` 语句捕获到这个 `ZeroDivisionError` 错误，因此 `except` 语句块里的代码会被执行。最后，`finally` 语句块里的代码也会被执行。**又因为错误得到了处理，所以之后程序会继续运行后续代码，输出 `END`**。

如果把除数0改成2，则执行结果如下：

```python
try...
result: 5
finally...
END
```

由于**没有错误发生**，所以 **`except` 语句块不会被执行**，但是 `finally` 语句块只要存在，就一定会被执行。

除了上面出现的 `ZeroDivisionError` 错误，在实际运行中，还有可能出现各种不同类型的错误。**不同类型的错误应该由不同的 `except` 语句块进行处理**。我们可以使用多个 `except` 语句来捕获不同类型的错误：

```python
try:
    print('try...')
    r = 10 / int('a')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
finally:
    print('finally...')
print('END')
```

因为当 `int()` 函数无法把参数转换为 `int` 类型时会抛出 `ValueError` 错误，我们用一个 `except` 来捕获和处理 `ValueError`，用另一个 `except` 来捕获并处理做除法可能产生的 `ZeroDivisionError`。

特别地，我们还**可以在 `except` 语句块后面加一个 `else` 语句块**。当错误没有发生时，就会执行 `else` 语句内的代码：

```python
try:
    print('try...')
    r = 10 / int('2')
    print('result:', r)
except ValueError as e:
    print('ValueError:', e)
except ZeroDivisionError as e:
    print('ZeroDivisionError:', e)
else:
    print('no error!')
finally:
    print('finally...')
print('END')
```

我们常说，在Python中一切皆对象。其实呀，Python中的错误也是采用面向对象实现的，**每一种错误都是一个类，`BaseException` 类是所有错误类型最顶级的父类**。在使用 `except` 时需要注意，它**不但会捕获所指定类型的错误，还把属于该类型子类的错误一并捕获**。比如：

```python
try:
    foo()
except ValueError as e:
    print('ValueError')
except UnicodeError as e:
    print('UnicodeError')
```

这里的第二个 `except` 永远也不会捕获到 `UnicodeError`，因为 `UnicodeError` 是 `ValueError` 的子类，如果出现了 `UnicodeError` 就一定会被第一个 `except` 语句捕获。

常见的错误类型和继承关系看这里：

[https://docs.python.org/3/library/exceptions.html#exception-hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)

在上一小节中，我们说到了使用错误码处理错误有两大缺点，一是**函数既可能返回正常结果也可能返回错误码**，二是**一旦发生错误必须层层上报**。那么使用 `try...except...finally...` 机制是否能克服这两个缺点呢？答案是肯定的！举个例子：

```python
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar('0')
    except Exception as e:
        print('Error:', e)
    finally:
        print('finally...')
```

这里我们在 `main` 函数中调用 `bar` 函数，在 `bar` 函数中调用 `foo` 函数。我们使用 `try` 模块来运行调用代码，当 `foo` 函数发生错误时，我们不需要返回错误码，也不需要一级级上报，程序会自动寻找对应的 `except` 语句进行错误处理。也即是说，**不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了**。这样一来，我们就能使用非常简洁的方式来处理程序运行中可能出现的错误了。

---
