# IO编程

## 什么是IO

IO在计算机中指**输入和输出（Input/Output）**。由于程序运行时，数据是在内存中驻留，并由CPU这个超快的计算核心来进行处理的（处理时会把数据从内存载入到CPU的高速缓存中），而涉及到数据交换的操作，比如磁盘读写、网络传输等的时候，就需要使用IO接口来协调了。

比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。

IO编程中，**流（Stream）是**一个很重要的概念，可以把流想象成一个水管，**数据就是水管里的水，但是只能单向流动**。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器程序和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。

由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在**速度严重不匹配**的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：

- 第一种方法是让CPU等待，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为**同步IO**；

- 第二种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以继续执行，这种模式称为**异步IO**。

同步和异步的区别就在于是否等待IO执行的结果。好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。

你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，**等做好了，我们再通知你**，这样你可以立刻去干别的事情（逛商场），这是异步IO。

很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员亲自跑过来找到你，这是**回调模式**，如果服务员发短信通知你，你就得不停地检查手机，这是**轮询模式**。总之，异步IO的复杂度远远高于同步IO。

**操作IO的能力都是由操作系统提供的**，**编程语言所做的知识把操作系统提供的低级C接口封装起来方便使用**，Python也不例外。后面的小节中会详细讨论Python的IO编程接口。

注意，本章的IO编程都是同步模式，异步IO由于复杂度太高，后续涉及到服务器端程序开发时会再作讨论。

---

<br>

## 文件读写

读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。

读写文件前，我们先必须了解一下，**在磁盘上读写文件的功能都是由操作系统提供的**，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。

---

### 读文件

要以读文件的模式打开一个文件对象，可以使用Python内置的 `open()` 函数，传入文件名（如果文件和代码文件在相同文件夹下就可以省略路径）和标示符 `'r'`：

```python
>>> f = open('/Users/michael/test.txt', 'r')
```

标示符 `'r'` 表示读，这样，我们就成功地打开了一个文件。

如果文件不存在，`open()` 函数就会抛出一个 `IOError` 的错误，并且给出错误码和详细的信息告诉你文件不存在：

```python
>>> f=open('/Users/michael/notfound.txt', 'r')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FileNotFoundError: [Errno 2] No such file or directory: '/Users/michael/notfound.txt'
```

如果文件打开成功，我们就可以调用 `read()` 方法来一次读取文件的全部内容，Python会把为文件的内容读到内存，返回的是一个 `str` 对象：

```python
>>> f.read()
'Hello, world!'
```

读取完毕后，如果不需要继续操作文件对象，我们就应当调用 `close()` 方法来关闭它。因为**文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的**：

```python
>>> f.close()
```

由于读写文件都有可能产生 `IOError`，一旦出错，后面的 `f.close()` 就不会调用。所以，为了**保证无论是否出错都能正确地关闭文件**，我们可以使用 `try ... finally` 来实现：

```python
try:
    f = open('/path/to/file', 'r')
    print(f.read())
finally:
    if f:
        f.close()
```

但是每次都这么写实在太繁琐，所以，Python引入了 `with` 语句来自动帮我们调用 `close()` 方法（（在[上一章](https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/08%E9%94%99%E8%AF%AF%E3%80%81%E8%B0%83%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95.md)中有 `with` 语句使用及原理的介绍））：

```python
with open('/path/to/file', 'r') as f:
    print(f.read())
```

这和前面的 `try ... finally` 实现的效果是一样的，但是代码更简洁，并且我们不必调用 `f.close()` 方法。

调用 `read()` 方法可以一次性读取文件的全部内容。但如果文件有10G，内存就爆了，所以，为了保险起见，我们可以多次调用 `read(size)` 方法，每次最多读取size个**字节**的内容。

但是有时候文件不一定有严格的格式，比方说读取一篇文章，这时按字节读取就不太合适了。但我们可以调用 `readline()` 方法，`readline()` 方法每次读取文件的一行内容。而调用 `readlines()` 方法则会一次读取文件的所有内容并按行返回一个 `list` 对象。我们可以：

```python
for line in f.readlines():
    print(line.strip()) # 把末尾的换行符'\n'删掉再打印
```

---

### 写文件

写文件和读文件是一样的，唯一区别是调用 `open()`函数时，传入标识符 `'w'` 或者 `'wb'` 表示写文本文件或写二进制文件：

```python
>>> f = open('/Users/michael/test.txt', 'w')
>>> f.write('Hello, world!')
>>> f.close()
```

你可以多次调用 `write()` 来写入文件，但是**最后一定要调用 `f.close()` 来关闭文件**。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是**放在内存中缓存起来，空闲的时候再慢慢写入**。只有调用 `close()` 方法时，操作系统才会保证把没有写入的数据全部写入磁盘。忘记 `close()` 的后果是**数据可能只有一部分写到了磁盘，剩下的丢失了**。为了避免这样的情况发生，类似上一节所介绍的，我们可以使用 `with` 语句自动管理上下文：

```python
with open('/Users/michael/test.txt', 'w') as f:
    f.write('Hello, world!')
```

如果要写入特定编码的文本文件，还可以给 `open()` 函数传入 `encoding` 参数，将要写入的字符串自动转换成指定编码。

---

### file-like Object

在Python中，除了文件对象之外，内存中的字节流，网络流，自定义流等等，拥有 `read()` 方法的对象统称为 **`file-like Object`**。`file-like Object` 不需要继承自特定的类，只要有 `read()` 方法就行（文件对象的其他方法不一定都需要实现，可以看看[官方说明](https://docs.python.org/2.4/lib/bltin-file-objects.html)），这得益于Python鸭子类型的实现。`StringIO` 就是在内存中创建的 `file-like Object`，常用作临时缓冲。

---

### 二进制文件

前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用 `'rb'` 模式打开文件即可：

```python
>>> f = open('/Users/michael/test.jpg', 'rb')
>>> f.read()
b'\xff\xd8\xff\xe1\x00\x18Exif\x00\x00...' # 十六进制表示的字节
```

---

### 字符编码

要读取非UTF-8编码的文本文件，可以给 `open()` 函数传入 `encoding` 参数，例如，读取GBK编码的文件：

```python
>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk')
>>> f.read()
'测试'
```

遇到有些编码不规范的文件，你可能会遇到 `UnicodeDecodeError`，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，`open()` 函数还接收一个 `errors` 参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：

```python
>>> f = open('/Users/michael/gbk.txt', 'r', encoding='gbk', errors='ignore')
```

---

### 小结

在Python中，文件读写是通过 `open()` 函数打开的文件对象完成的。使用 `with` 语句操作文件IO是个好习惯。

---

<br>

## StringIO和BytesIO

### StringIO

很多时候，数据读写不一定是对文件进行的，我们也可以在内存中进行读写操作。

`StringIO` 顾名思义就是**在内存中读写 `str`**。

要把 `str` 写入 `StringIO`，我们需要先创建一个 `StringIO` 对象，然后，像文件一样写入即可：

```python
>>> from io import StringIO
>>> f = StringIO()
>>> f.write('hello')
5
>>> f.write(' ')
1
>>> f.write('world!')
6
>>> print(f.getvalue())
hello world!
```

`getvalue()` 方法用于获得 `StringIO` 中的 `str`。

读取 `StringIO` 的方法也和读文件类似：

```python
>>> from io import StringIO
>>> f = StringIO('Hello!\nHi!\nGoodbye!') # 用一个str初始化StringIO
>>> while True:
...     s = f.readline()
...     if s == '':
...         break
...     print(s.strip())
...
Hello!
Hi!
Goodbye!
```

---


