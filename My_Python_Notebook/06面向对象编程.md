# 面向对象编程

## 基本概念

面向对象编程 —— Object Oriented Programming，简称OOP，是一种编程思想。OOP把对象作为程序的基本单元，**一个对象不仅包含数据还包含操作数据的函数**。

### 对比面向过程与面向对象

- **面向过程编程（Procedural programming）**：把计算机程序视为**一系列子程序的集合**。为了简化程序设计，面向过程把子程序继续切分为更小的子程序，也即把大的功能分为若干小的功能进行实现，从而降低系统的复杂度，这种做法也称为**模块化（Modularity）**。

- **面向对象编程（Object-oriented programming）**：把计算机程序视为**一组对象的集合**，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

下面以保存和打印学生成绩表为例，分别展示面向过程编程和面向对象编程的不同：

**面向过程编程**：

```python
def save_score(name, score):
    return {'name':name, 'score':score}

def print_score(std):
    print('%s: %s' % (std['name'], std['score']))

bart = save_score('Michael', 98)
lisa = save_score('Bob', 81)

print_score(bart)
print_score(lisa)
```

面向过程编程其实就是细分功能并逐步实现，这里分出了保存成绩和打印成绩两个细的功能，并分别封装成子程序（或者说函数），然后通过调用各个子程序来实现程序的最终目标（保存并打印成绩）。

**面向对象编程**：

```python
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score
    def print_score(self):
        print('%s: %s' % (self.name, self.score))

bart = Student('Bart Simpson', 59)
lisa = Student('Lisa Simpson', 87)
bart.print_score()
lisa.print_score()
```

面向对象编程强调程序的主体是对象，这里我们把学生抽象成一个**类（class）**，这个类的对象拥有 `name` 和 `score` 这两个**属性（Property）**，那么保存成绩就是把学生类实例化为**对象（object）**，打印成绩就是给每个学生对象发送一个 `print_score` 的**消息（message）**，让对象自己打印自己的属性。这个发送消息的过程又称为调用对象的**方法（method）**，注意区分函数和方法。

---

### 五种编程范式的区分

这一小节是额外加上的，因为之前第4章[函数式编程](https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/04%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md)也讲了一种编程范式，这章又引入了面向过程编程和面向对象编程的概念，所以就在这里整理一下。也可以直接查看维基词条：[Wikipedia - Procedural programming](https://en.wikipedia.org/wiki/Procedural_programming#Comparison_with_imperative_programming) 以及引用的文章，讲得比较细致和清晰。更详细的可以查找专门讲编程范式的书籍来浏览。

#### 面向过程编程（Procedural programming）

面向过程就是拆分和逐步实现，前一小节已经说过了，这里不再累述。

#### 命令式编程（Imperative programming）

有时候面向过程编程又称为命令式编程，两者经常混用，但它们之间还是有一点差别的。面向过程编程依赖于**块**和**域**，比方说有 `while`，`for` 等保留字；而命令式编程则没有这样的特征，一般采用 `goto` 或者分支来实现。

#### 面向对象编程（Object-oriented programming）

面向对象也在上一小节简单介绍过了，它比面向过程编程抽象程度更高，面向过程将一个编程任务划分为若干变量、数据结构和子程序的组合，而面向对象则是划分为对象，对象的行为（方法）、使用对象的数据（成员/属性）的接口。面向过程编程使用子程序去操作数据，而面向对象则把这两者结合为对象，每一个对象的方法作用在自身上。

#### 函数式编程（Functional programming）

在模块化和代码复用上，函数式编程和面向过程编程是很像的。但函数式编程中不再强调指令（赋值语句）。面向过程编写出的程序是一组指令的集合，这些指令可能会隐式地修改了一些公用的状态，而函数式编程则规避了这一点，**每一个语句都是一个表达式，只依赖于自己而不依赖外部状态**，因为我们现在所用的计算机都是基于指令运作的，所以函数式编程的效率会稍低一些，但是函数式编程一个很大的好处就是，既然每个语句都是独立的，那么就**很容易实现并行化**了。

#### 逻辑编程（Logic programming）

逻辑编程是一种我们现在比较少接触的变成范式，它关注于表达问题是什么是不是怎样解决问题。感兴趣的话可以了解一下Prolog语言。

---

### 面向对象编程的三大特点

1. **数据封装**
2. **继承**
3. **多态**

---

<br>

## 类和实例

在Python中定义类是通过 `class` 关键字完成的，像前面例子一样：

```python
class Student(object):
    pass
```

定义类的格式是 `class 类名(继承的类名)` 。 **类名一般用大写字母开头**，关于继承的知识会留在后续的章节里详述，**object类是所有类的父类**，在Python3中不写也行（既可以写作 `class Student:` 或 `class Student():`），会自动继承，详情可以看[python class inherits object](http://stackoverflow.com/questions/4015417/python-class-inherits-object)。

定义类以后，即使没有定义构造函数和属性，我们也可以实例化对象：

```python
>>> bart = Student()
>>> bart
<__main__.Student object at 0x10a67a590>
>>> Student
<class '__main__.Student'>
```

可以看到变量bart指向的就是一个Student类的实例，**每个实例的地址是不一样的**。

与静态语言不同，Python作为动态语言，我们可以自由地给一个实例变量绑定属性：

```python
>>> bart.name = 'Bart Simpson'
>>> bart.name
'Bart Simpson'
```

**绑定的属性在定义类时无须给出**，随时都可以给一个实例绑定新属性。 但是！**这样绑定的新属性仅仅绑定在这个实例上**，别的实例是没有的！ 也就是说，**同一个类的多个实例例拥有的属性可能不同**！

对于我们认为**必须绑定的属性**，可以通过定义特殊的 `__init__` 方法进行初始化，在创建实例时就进行绑定：

```python
class Student(object):

def __init__(self, name, score):
    self.name = name
    self.score = score
```

使用 `__init__` 方法要注意：

1. 第一个参数永远是 `self`，**指向创建出的实例本身**。
2. **有了 `__init__` 方法，创建实例时就不能传入空的参数，必须传入与 `__init__` 方法匹配的参数**，参数self不用传，Python解释器会自动传入。

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.name
'Bart Simpson'
>>> bart.score
59
```

### 数据封装

数据封装是面向对象编程特点之一，对于类的每个实例而言，属性访问可以通过函数来实现。 既然**实例本身拥有属性数据**，那么访问实例的数据就不需要通过外面的函数实现，可以**直接在类的内部定义访问数据的函数**。

**利用内部定义的函数，就把数据封装起来了**，这些函数和类本身是关联的，称为**类的方法**。

```python
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
```

依然是前面的例子，可以看到在类中定义方法和外面定义的函数**唯一区别就是方法的第一个参数永远是实例变量 `self`**。其他一致，仍然可以用默认参数，可变参数，关键字参数和命名关键字参数等参数形式。和创建实例一样，调用方法时不需传入self。

对于外部，**类的方法实现细节不用了解**，只需要知道怎样调用，能返回什么就可以了。

---
