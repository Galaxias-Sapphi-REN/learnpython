# 面向对象编程

## 基本概念

面向对象编程 —— Object Oriented Programming，简称OOP，是一种编程思想。OOP把对象作为程序的基本单元，**一个对象不仅包含数据还包含操作数据的函数**。

### 对比面向过程与面向对象

- **面向过程编程（Procedural programming）**：把计算机程序视为**一系列子程序的集合**。为了简化程序设计，面向过程把子程序继续切分为更小的子程序，也即把大的功能分为若干小的功能进行实现，从而降低系统的复杂度，这种做法也称为**模块化（Modularity）**。

- **面向对象编程（Object-oriented programming）**：把计算机程序视为**一组对象的集合**，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。

下面以保存和打印学生成绩表为例，分别展示面向过程编程和面向对象编程的不同：

**面向过程编程**：

```python
def save_score(name, score):
    return {'name':name, 'score':score}

def print_score(std):
    print('%s: %s' % (std['name'], std['score']))

bart = save_score('Michael', 98)
lisa = save_score('Bob', 81)

print_score(bart)
print_score(lisa)
```

面向过程编程其实就是细分功能并逐步实现，这里分出了保存成绩和打印成绩两个细的功能，并分别封装成子程序（或者说函数），然后通过调用各个子程序来实现程序的最终目标（保存并打印成绩）。

**面向对象编程**：

```python
class Student(object):
    def __init__(self, name, score):
        self.name = name
        self.score = score
    def print_score(self):
        print('%s: %s' % (self.name, self.score))

bart = Student('Bart Simpson', 59)
lisa = Student('Lisa Simpson', 87)
bart.print_score()
lisa.print_score()
```

面向对象编程强调程序的主体是对象，这里我们把学生抽象成一个**类（class）**，这个类的对象拥有 `name` 和 `score` 这两个**属性（Property）**，那么保存成绩就是把学生类实例化为**对象（object）**，打印成绩就是给每个学生对象发送一个 `print_score` 的**消息（message）**，让对象自己打印自己的属性。这个发送消息的过程又称为调用对象的**方法（method）**，注意区分函数和方法。

---

### 五种编程范式的区分

这一小节是额外加上的，因为之前第4章[函数式编程](https://github.com/familyld/learnpython/blob/master/My_Python_Notebook/04%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B.md)也讲了一种编程范式，这章又引入了面向过程编程和面向对象编程的概念，所以就在这里整理一下。也可以直接查看维基词条：[Wikipedia - Procedural programming](https://en.wikipedia.org/wiki/Procedural_programming#Comparison_with_imperative_programming) 以及引用的文章，讲得比较细致和清晰。更详细的可以查找专门讲编程范式的书籍来浏览。

#### 面向过程编程（Procedural programming）

面向过程就是拆分和逐步实现，前一小节已经说过了，这里不再累述。

#### 命令式编程（Imperative programming）

有时候面向过程编程又称为命令式编程，两者经常混用，但它们之间还是有一点差别的。面向过程编程依赖于**块**和**域**，比方说有 `while`，`for` 等保留字；而命令式编程则没有这样的特征，一般采用 `goto` 或者分支来实现。

#### 面向对象编程（Object-oriented programming）

面向对象也在上一小节简单介绍过了，它比面向过程编程抽象程度更高，面向过程将一个编程任务划分为若干变量、数据结构和子程序的组合，而面向对象则是划分为对象，对象的行为（方法）、使用对象的数据（成员/属性）的接口。面向过程编程使用子程序去操作数据，而面向对象则把这两者结合为对象，每一个对象的方法作用在自身上。

#### 函数式编程（Functional programming）

在模块化和代码复用上，函数式编程和面向过程编程是很像的。但函数式编程中不再强调指令（赋值语句）。面向过程编写出的程序是一组指令的集合，这些指令可能会隐式地修改了一些公用的状态，而函数式编程则规避了这一点，**每一个语句都是一个表达式，只依赖于自己而不依赖外部状态**，因为我们现在所用的计算机都是基于指令运作的，所以函数式编程的效率会稍低一些，但是函数式编程一个很大的好处就是，既然每个语句都是独立的，那么就**很容易实现并行化**了。

#### 逻辑编程（Logic programming）

逻辑编程是一种我们现在比较少接触的变成范式，它关注于表达问题是什么是不是怎样解决问题。感兴趣的话可以了解一下Prolog语言。

---

### 面向对象编程的三大特点

1. **数据封装**
2. **继承**
3. **多态**

---

<br>

## 类和实例

在Python中定义类是通过 `class` 关键字完成的，像前面例子一样：

```python
class Student(object):
    pass
```

定义类的格式是 `class 类名(继承的类名)` 。 **类名一般用大写字母开头**，关于继承的知识会留在后续的章节里详述，**object类是所有类的父类**，在Python3中不写也行（既可以写作 `class Student:` 或 `class Student():`），会自动继承，详情可以看[python class inherits object](http://stackoverflow.com/questions/4015417/python-class-inherits-object)。

定义类以后，即使没有定义构造函数和属性，我们也可以实例化对象：

```python
>>> bart = Student()
>>> bart
<__main__.Student object at 0x10a67a590>
>>> Student
<class '__main__.Student'>
```

可以看到变量bart指向的就是一个Student类的实例，**每个实例的地址是不一样的**。

与静态语言不同，Python作为动态语言，我们可以自由地给一个实例变量绑定属性：

```python
>>> bart.name = 'Bart Simpson'
>>> bart.name
'Bart Simpson'
```

**绑定的属性在定义类时无须给出**，随时都可以给一个实例绑定新属性。 但是！**这样绑定的新属性仅仅绑定在这个实例上**，别的实例是没有的！ 也就是说，**同一个类的多个实例例拥有的属性可能不同**！

对于我们认为**必须绑定的属性**，可以通过定义特殊的 `__init__` 方法进行初始化，在创建实例时就进行绑定：

```python
class Student(object):

def __init__(self, name, score):
    self.name = name
    self.score = score
```

使用 `__init__` 方法要注意：

1. 第一个参数永远是 `self`，**指向创建出的实例本身**。
2. **有了 `__init__` 方法，创建实例时就不能传入空的参数，必须传入与 `__init__` 方法匹配的参数**，参数self不用传，Python解释器会自动传入。

```python
>>> bart = Student('Bart Simpson', 59)
>>> bart.name
'Bart Simpson'
>>> bart.score
59
```

### 数据封装

数据封装是面向对象编程特点之一，对于类的每个实例而言，属性访问可以通过函数来实现。 既然**实例本身拥有属性数据**，那么访问实例的数据就不需要通过外面的函数实现，可以**直接在类的内部定义访问数据的函数**。

**利用内部定义的函数，就把数据封装起来了**，这些函数和类本身是关联的，称为**类的方法**。

```python
class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print('%s: %s' % (self.name, self.score))
```

依然是前面的例子，可以看到在类中定义方法和外面定义的函数**唯一区别就是方法的第一个参数永远是实例变量 `self`**。其他一致，仍然可以用默认参数，可变参数，关键字参数和命名关键字参数等参数形式。和创建实例一样，调用方法时不需传入self。

对于外部，**类的方法实现细节不用了解**，只需要知道怎样调用，能返回什么就可以了。

---

### 访问限制

尽管前一节中我们把数据用方法进行了封装，但事实上，实例化对象后，我们依然可以直接通过属性名来访问一个实例的属性值，并且自由地修改属性值。要让实例的内部属性不被外部访问，只需要在属性的名称前加上两个下划线 `__` 就可以了，此时属性就转换成了**私有属性**。

```python
>>> class Student():
...     def __init__(self, name, score):
...         self.__name = name   # 绑定私有属性__name
...         self.__score = score # 绑定私有属性__score
...     def print_score(self):   # 通过方法访问私有属性
...         print(self.__name, self.__score)
...
>>> bart = Student('Bart', 98) # 创建一个Student类的实例bart
>>> bart.__name                # 由于访问限制的保护，对外部而言，实例bart是没有__name这个属性的
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute '__name'
>>> bart.__score                # 由于访问限制的保护，对外部而言，实例bart是没有__score这个属性的
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Student' object has no attribute '__score'
>>> bart.print_score()          # 但是通过print_score方法可以访问该实例的__name属性和__score属性
Bart 98
```

这是怎么实现的呢？其实呀，不能访问的实质是Python解释器**对外给私有变量添加了前缀** `_类名`，比如把 `__name` 会被改成 `_Student__name` 。所以我们在外部（即不是通过类的方法）访问时，`__name` 属性是不存在的，但访问 `_Student__name` 属性就可以了：

```python
>>> bart._Student__name
'Bart'
```

所以说，**即使有访问限制，外部依然可以访问和修改内部属性**，Python没有任何机制预防这一点，只有靠使用者自己注意了。

还有一点必须明白。**使用访问限制跟绑定属性是不冲突的**，所以虽然对内而言存在 `__name` 属性，但对外而言这个属性不存在，我们依然可以给实例绑定一个 `__name` 属性：

```python
>>> bart.__name = 'Alice' # 外部绑定__name属性
>>> bart.__name           # 现在外部可以访问__name属性了
'Alice'
>>> bart.print_score()    # 但对内部方法来说，__name属性依然是原来的
Bart 98
```

Python同样**没有任何机制防止我们给实例绑定一个和私有属性同名的属性**，从外部是可以访问这样绑定的属性的，但对内部方法而言，这种**绑定的赋值不会覆盖私有属性原来的值**，所以极容易出错，只有靠使用者自己注意了。

通过 `dir(bart)` 可以查看实例包含的所有变量（属性和方法）：

```python
>>> dir(bart)
['_Student__name', '_Student__score', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__',
'__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__le__', '__lt__', '__module__',
'__name', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__',
'__subclasshook__', '__weakref__', 'print_score']
```

在Python中，变量名类似 `__xxx__` 的，也就是**以双下划线开头，并且以双下划线结尾**的，是**特殊变量**，特殊变量允许直接访问，**注意私有变量不要这样取名**。有时会看到以**一个下划线开头**的变量名，比如 `_name`，这样的变量外部是可以访问的，不属于访问限制，但是按照约定，这样的变量我们应**视为私有变量，不应在外部直接访问**。

---

### 获取和修改限制访问的属性

对于限制访问的属性，外部代码还是需要进行访问和修改的，我们可以在类中定义对应的get方法和set方法：

```python
>>> class Student():
...     def __init__(self, name, score):
...         self.__name = name   # 绑定私有属性__name
...         self.__score = score # 绑定私有属性__score
...     def print_score(self):   # 通过方法访问私有属性
...         print(self.__name, self.__score)
...     def get_name(self):
...         return self.__name
...     def get_score(self):
...         return self.__score
...     def set_score(self, score):
...     if 0 <= score <= 100:
...         self.__score = score
...     else:
...         raise ValueError('bad score')
```

通过类的set方法修改属性值，而不直接在外部修改有一个明显的好处，我们**可以在类的方法中对参数做检查，避免传入无效的参数**。 比如这里可以限制修改成绩时成绩的范围必须是0~100，超出就报错。

---

<br>
