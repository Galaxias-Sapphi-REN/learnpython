# 模块

在开发过程中，一个文件里代码越长就越不容易维护。

为了编写易于维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。

在Python中，**一个.py文件就称之为一个模块（Module）**。

## 使用模块的几个好处

- 大大提高了代码的可维护性。
- 编写代码不必从零开始。当一个模块编写完毕，就可以被其他模块引用。
- 避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中。 但还是要注意**变量名尽量不要与BIF（built-in functions，内建函数）名字冲突**。

---

<br>

## 模块名和包名

由于不同的人编写的模块名可能会相同，为了**避免模块名冲突**，Python又引入了**按目录来组织模块**的方法，称为**包（Package）**。

![图片](http://oe0e8k1nf.bkt.clouddn.com/My_Python_Notebook_Module0.png)

假设图中abc和xyz两个模块的名字和外面其他模块名字冲突了，我们可以通过包来组织模块，避免冲突。 只要**顶层包名(也即这里的mycompany文件夹)不同即可**。

此时abc的**模块名**变为 `mycompany.abc`, xyz的**模块名**变为 `mycompany.xyz`。

**Notice**：

- **注意区分模块和模块名**！两者不一定相同！（比如上面的模块 `abc` 和它的模块名 `mycompany.abc`）

- **每个包目录下都必须有一个 `__init__.py` 文件**，否则Python就不会把这个文件夹当作一个包。  `__init__.py`可以是空文件，也可以有Python代码，它本身就是一个模块，并且**它的模块名就是包名**(这里是 `mycompany`)。

![图片](http://oe0e8k1nf.bkt.clouddn.com/My_Python_Notebook_Module1.png)

**包结构可以是多级的**。比方说这里www.py的**模块名**就是 `mycompany.web.www` 。 两个utils.py的模块名分别是 `mycompany.utils` 和 `mycompany.web.utils`，它们不会冲突 。 `mycompany.web` 这个模块名对应的就是web目录下的 `__init__.py` 模块。

**Notice**:

自己创建的模块的模块名**不要和Python自带的模块的模块名冲突**！ 比如系统自带sys模块，自己的模块就不要命名sys.py，否则无法会无法正确import自带的sys模块。

---

<br>

## 使用模块

Python本身就内置了很多模块可以直接import使用。 下面我们自己编写一个hello模块作为例子：

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' a test module '

__author__ = 'Michael Liao'

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print('Hello, world!')
    elif len(args)==2:
        print('Hello, %s!' % args[1])
    else:
        print('Too many arguments!')

if __name__=='__main__':
    test()
```

### 例子解析

#### Python模块的标准文件模板

文件的第1行和第2行是**标准注释**：

- 第1行注释是用于**声明使用什么程序来执行这个脚本**，它可以**使得这个脚本能在Unix/Linux/Mac上直接运行**（也即**可以使用 `./hello.py` 的形式执行**而不是 `python hello.py` 的形式）。如果系统装了多个版本的python，`#!/usr/bin/env python3` 会保证调用环境变量 `$PATH` 中的第一个叫python3的程序来执行脚本。又因为在一些系统中python能被重定向到python3，也即默认使用python3，所以直接用 `#!/usr/bin/env python` 也是可以的。还有一种写法是 `#!/usr/bin/python`，这样写就是指定一个路径，兼容性不如使用env的写法好。注意，如果我们使用 `python hello.py` 或者 `python3 hello.py` 的方式**直接指定解释器来执行的话，这句注释就没用了**。另外，在Windows下**这句注释也是被忽略的**，但**为了代码的兼容性最好还是写上**。

- 第2行注释表示这个.py脚本文件中的代码文本使用的是UTF-8编码。**在Python2中**，代码文本只可以包含ASCII，要用到中文就得采用很别扭的escape写法。后来有了[PEP 0263标准](https://www.python.org/dev/peps/pep-0263/)，规定了**显式声明代码文本编码**的方法。一般有三种格式，包括：能被大部分编辑器识别的 `# -*- coding: utf-8 -*-`，最简单的 `# coding=utf-8` 以及vim的 `# vim: set fileencoding=utf-8` （其实还可以写成别的方式，主要看编辑器怎样正则匹配这一行）。当然这里的utf-8可以换为其他编码。注意**编码声明必须放在代码文件的第一行或第二行**。

第4行是一个字符串，表示模块的文档注释，**任何模块代码的第一个字符串都被视为模块的文档注释；**

第6行使用__author__变量记录模块作者。

以上就是**Python模块的标准文件模板**，不写其实也没关系，但养成良好的习惯更好。

#### 正式代码部分

1.导入sys模块

使用Python内置的sys模块，首先要导入模块： `import sys`。 导入之后，相当于创建了一个**变量sys，该变量指向sys模块，通过这个变量可以访问sys模块的全部功能**。

2.使用argv变量获取参数列表

**sys模块有一个argv变量**，用list存储了**命令行的所有参数**。 argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：

在命令行执行 `python3 hello.py` 获得的 `sys.argv` 就是 `['hello.py']`；

在命令行执行 `python3 hello.py Michael` 获得的 `sys.argv` 就是 `['hello.py', 'Michael]`。 要获取字符串 `'Michael'` 只需要调用 `sys.argv[1]`。 **argv本身是一个list对象**。

3.条件判断

```python
if __name__=='__main__':
    test()
```

在hello模块中我们定义了一个test函数，这个条件判断的意思就是，如果执行这个.py文件时，`__name__` 变量等于`'__main__'`的话就执行test()函数。

其中 `__name__` 变量是个特殊变量，当我们**在命令行执行**hello.py时，Python解释器就会把它赋值为 `__main__`。

如果在别的地方导入hello模块，不会有对 `__name__` 赋值的操作，if判断就会失败。 借助这个特性，我们可以**在if判断中编写一些额外的代码**，用于在命令行运行时执行。**运行测试**就需要这样做。
